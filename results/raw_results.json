{
  "timestamp": "2025-12-21T22:00:33.450355",
  "total_results": 100,
  "results": [
    {
      "problem_id": "valid-sudoku",
      "problem_title": "Valid Sudoku",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 35,
      "passed_tests": 1,
      "api_time": 71.6178469657898,
      "execution_time": 1.0329220294952393,
      "error": "Test execution error: invalid literal for int() with base 10: '['\nTest execution error: 'list' object has no attribute 'add'\nTest execution error: invalid literal for int() with base 10: '['\nTest execution error: 'list' object has no attribute 'add'\nTest execution error: 'list' object has no attribute 'add'\nTest execution error: invalid literal for int() with base 10: '['\nTest execution error: invalid literal for int() with base 10: '['\nTest execution error: 'list' object has no attribute 'add'\n",
      "generated_code": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        rows = [set() for _ in range(9)]\n        cols = [set() for _ in range(9)]\n        boxes = [[set() for _ in range(3)] for _ in range(3)]\n\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == \".\":\n                    continue\n                num = int(board[i][j])\n                k = (i // 3) * 3 + j // 3\n                if (num in rows[i]) or (num in cols[j]) or (num in boxes[k]):\n                    return False\n                rows[i].add(num)\n                cols[j].add(num)\n                boxes[k].add(num)\n        return True"
    },
    {
      "problem_id": "rotate-list",
      "problem_title": "Rotate List",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 101,
      "passed_tests": 0,
      "api_time": 20.79955291748047,
      "execution_time": 0.6383039951324463,
      "error": "Test execution error: 'list' object has no attribute 'next'\nTest execution error: 'list' object has no attribute 'next'\nTest execution error: 'list' object has no attribute 'next'\nTest execution error: 'list' object has no attribute 'next'\nTest execution error: 'list' object has no attribute 'next'\nTest execution error: 'list' object has no attribute 'next'\nTest execution error: 'list' object has no attribute 'next'\nTest execution error: 'list' object has no attribute 'next'\nTest execution error",
      "generated_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next or k == 0:\n            return head\n        n = 1\n        tail = head\n        while tail.next:\n            n += 1\n            tail = tail.next\n        k %= n\n        if k == 0:\n            return head\n        fast, slow = head, head\n        for _ in range(k):\n            fast = fast.next\n        while fast.next:\n            fast, slow = fast.next, slow.next\n        ans = slow.next\n        slow.next = None\n        tail.next = head\n        return ans"
    },
    {
      "problem_id": "unique-binary-search-trees",
      "problem_title": "Unique Binary Search Trees",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": true,
      "total_tests": 14,
      "passed_tests": 14,
      "api_time": 9.175603151321411,
      "execution_time": 0.156203031539917,
      "error": null,
      "generated_code": "class Solution:\n    def numTrees(self, n: int) -> int:\n        f = [1] + [0] * n\n        for i in range(n + 1):\n            for j in range(i):\n                f[i] += f[j] * f[i - 1 - j]\n        return f[n]"
    },
    {
      "problem_id": "distinct-subsequences",
      "problem_title": "Distinct Subsequences",
      "difficulty": "Hard",
      "model": "deepseek-leetcode-p3",
      "passed": true,
      "total_tests": 101,
      "passed_tests": 101,
      "api_time": 17.628610849380493,
      "execution_time": 0.31580686569213867,
      "error": null,
      "generated_code": "class Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        m, n = len(s), len(t)\n        f = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            f[i][0] = 1\n        for i, a in enumerate(s, 1):\n            for j, b in enumerate(t, 1):\n                if a == b:\n                    f[i][j] = f[i - 1][j - 1] + f[i - 1][j]\n                else:\n                    f[i][j] = f[i - 1][j]\n        return f[-1][-1]"
    },
    {
      "problem_id": "best-time-to-buy-and-sell-stock",
      "problem_title": "Best Time To Buy And Sell Stock",
      "difficulty": "Easy",
      "model": "deepseek-leetcode-p3",
      "passed": true,
      "total_tests": 99,
      "passed_tests": 99,
      "api_time": 8.75573205947876,
      "execution_time": 0.10248684883117676,
      "error": null,
      "generated_code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        ans = mx = 0\n        for x in prices[::-1]:\n            ans = max(ans, mx - x)\n            mx = max(mx, x)\n        return ans"
    },
    {
      "problem_id": "valid-palindrome",
      "problem_title": "Valid Palindrome",
      "difficulty": "Easy",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 21,
      "passed_tests": 19,
      "api_time": 13.152835130691528,
      "execution_time": 0.1370229721069336,
      "error": null,
      "generated_code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        i, j = 0, len(s) - 1\n        while i < j:\n            while i < j and not s[i].isalnum():\n                i += 1\n            while i < j and not s[j].isalnum():\n                j -= 1\n            if s[i].lower() != s[j].lower():\n                return False\n            i, j = i + 1, j - 1\n        return True"
    },
    {
      "problem_id": "word-ladder",
      "problem_title": "Word Ladder",
      "difficulty": "Hard",
      "model": "deepseek-leetcode-p3",
      "passed": true,
      "total_tests": 13,
      "passed_tests": 13,
      "api_time": 19.3720600605011,
      "execution_time": 0.14917492866516113,
      "error": null,
      "generated_code": "class Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        if endWord not in wordList:\n            return 0\n        q = deque([beginWord])\n        vis = {beginWord}\n        ans = 1\n        while q:\n            for _ in range(len(q)):\n                s = q.popleft()\n                if s == endWord:\n                    return ans\n                for t in wordList:\n                    if t not in vis and sum(a != b for a, b in zip(s, t)) == 1:\n                        q.append(t)\n                        vis.add(t)\n            ans += 1\n        return 0"
    },
    {
      "problem_id": "sum-root-to-leaf-numbers",
      "problem_title": "Sum Root To Leaf Numbers",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 93,
      "passed_tests": 0,
      "api_time": 19.616992712020874,
      "execution_time": 0.07293295860290527,
      "error": "Test execution error: 'list' object has no attribute 'val'\nTest execution error: 'str' object has no attribute 'val'\nTest execution error: 'list' object has no attribute 'val'\nTest execution error: 'list' object has no attribute 'val'\nTest execution error: 'list' object has no attribute 'val'\nTest execution error: 'str' object has no attribute 'val'\nTest execution error: 'list' object has no attribute 'val'\nTest execution error: 'list' object has no attribute 'val'\nTest execution error: 'list' o",
      "generated_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        def dfs(root, s):\n            if root is None:\n                return 0\n            s = s * 10 + root.val\n            if root.left == root.right:\n                return s\n            return dfs(root.left, s) + dfs(root.right, s)\n\n        return dfs(root, 0)"
    },
    {
      "problem_id": "sort-list",
      "problem_title": "Sort List",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 109,
      "passed_tests": 0,
      "api_time": 28.52250599861145,
      "execution_time": 0.06610417366027832,
      "error": "Test execution error: 'list' object has no attribute 'next'\nTest execution error: 'list' object has no attribute 'next'\nTest execution error: 'list' object has no attribute 'next'\nTest execution error: 'list' object has no attribute 'next'\nTest execution error: 'list' object has no attribute 'next'\nTest execution error: 'list' object has no attribute 'next'\nTest execution error: 'list' object has no attribute 'next'\nTest execution error: 'list' object has no attribute 'next'\nTest execution error",
      "generated_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow, fast = slow.next, fast.next.next\n        right = self.sortList(slow.next)\n        slow.next = None\n        left = self.sortList(head)\n        dummy = ListNode()\n        tail = dummy\n        while left and right:\n            if left.val <= right.val:\n                tail.next, left = left, left.next\n            else:\n                tail.next, right = right, right.next\n            tail = tail.next\n        tail.next = left or right\n        return dummy.next"
    },
    {
      "problem_id": "two-sum-ii-input-array-is-sorted",
      "problem_title": "Two Sum Ii Input Array Is Sorted",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 89,
      "passed_tests": 86,
      "api_time": 16.64112615585327,
      "execution_time": 0.07096076011657715,
      "error": null,
      "generated_code": "class Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        l, r = 0, len(numbers) - 1\n        while l < r:\n            s = numbers[l] + numbers[r]\n            if s == target:\n                return [l + 1, r + 1]\n            if s > target:\n                r -= 1\n            else:\n                l += 1"
    },
    {
      "problem_id": "minimum-size-subarray-sum",
      "problem_title": "Minimum Size Subarray Sum",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 73,
      "passed_tests": 39,
      "api_time": 16.22379183769226,
      "execution_time": 0.050171852111816406,
      "error": null,
      "generated_code": "class Solution:\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\n        n = len(nums)\n        s = list(accumulate(nums, initial=0))\n        ans = inf\n        for i in range(1, n + 1):\n            j = bisect_left(s, s[i] - target)\n            if j:\n                ans = min(ans, i - j + 1)\n        return 0 if ans == inf else ans"
    },
    {
      "problem_id": "contains-duplicate-ii",
      "problem_title": "Contains Duplicate Ii",
      "difficulty": "Easy",
      "model": "deepseek-leetcode-p3",
      "passed": true,
      "total_tests": 106,
      "passed_tests": 106,
      "api_time": 10.774158954620361,
      "execution_time": 0.06612706184387207,
      "error": null,
      "generated_code": "class Solution:\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\n        d = {}\n        for i, x in enumerate(nums):\n            if x in d and i - d[x] <= k:\n                return True\n            d[x] = i\n        return False"
    },
    {
      "problem_id": "basic-calculator-ii",
      "problem_title": "Basic Calculator Ii",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": true,
      "total_tests": 171,
      "passed_tests": 171,
      "api_time": 22.094258785247803,
      "execution_time": 0.06927990913391113,
      "error": null,
      "generated_code": "class Solution:\n    def calculate(self, s: str) -> int:\n        stk = []\n        sign = \"+\"\n        n, i = 0, 0\n        while i < len(s):\n            if s[i].isdigit():\n                n = n * 10 + int(s[i])\n            if s[i] in \"+-*/\" or i == len(s) - 1:\n                match sign:\n                    case \"+\":\n                        stk.append(n)\n                    case \"-\":\n                        stk.append(-n)\n                    case \"*\":\n                        stk.append(stk.pop() * n)\n                    case \"/\":\n                        stk.append(int(stk.pop() / n))\n                sign = s[i]\n                n = 0\n            i += 1\n        return sum(stk)"
    },
    {
      "problem_id": "binary-tree-paths",
      "problem_title": "Binary Tree Paths",
      "difficulty": "Easy",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 79,
      "passed_tests": 0,
      "api_time": 21.936925172805786,
      "execution_time": 0.05923104286193848,
      "error": "Test execution error: 'list' object has no attribute 'val'\nTest execution error: 'str' object has no attribute 'val'\nTest execution error: 'str' object has no attribute 'val'\nTest execution error: 'str' object has no attribute 'val'\nTest execution error: 'str' object has no attribute 'val'\nTest execution error: 'list' object has no attribute 'val'\nTest execution error: 'list' object has no attribute 'val'\nTest execution error: 'str' object has no attribute 'val'\nTest execution error: 'str' objec",
      "generated_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:\n        def dfs(root: TreeNode):\n            if root is None:\n                return\n            path.append(str(root.val))\n            if root.left is None and root.right is None:\n                ans.append('->'.join(path))\n            else:\n                dfs(root.left)\n                dfs(root.right)\n            path.pop()\n\n        ans = []\n        path = []\n        dfs(root)\n        return ans"
    },
    {
      "problem_id": "create-maximum-number",
      "problem_title": "Create Maximum Number",
      "difficulty": "Hard",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 120,
      "passed_tests": 0,
      "api_time": 60.43314599990845,
      "execution_time": 0.06943702697753906,
      "error": "Test execution error: Solution.findMaxArray() missing 1 required positional argument: 'k'\nTest execution error: Solution.findMaxArray() missing 1 required positional argument: 'k'\nTest execution error: Solution.findMaxArray() missing 1 required positional argument: 'k'\nTest execution error: Solution.findMaxArray() missing 1 required positional argument: 'k'\nTest execution error: Solution.findMaxArray() missing 1 required positional argument: 'k'\nTest execution error: Solution.findMaxArray() miss",
      "generated_code": "class Solution:\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\n        m, n = len(nums1), len(nums2)\n        ans = [0] * k\n        for i in range(max(0, k - n), min(m, k) + 1):\n            j = k - i\n            a = self.findMaxArray(nums1, i)\n            b = self.findMaxArray(nums2, j)\n            c = self.merge(a, b)\n            if ans < c:\n                ans = c[:]\n        return ans\n\n    def findMaxArray(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        stk = [0] * (n + 1)\n        top = 0\n        remain = n - k\n        for x in nums:\n            while top and stk[top - 1] < x and remain > 0:\n                top -= 1\n                remain -= 1\n            if top < len(stk):\n                stk[top] = x\n                top += 1\n        return stk[:top]\n\n    def merge(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        m, n = len(nums1), len(nums2)\n        if m == 0:\n            return nums2\n        if n == 0:\n            return nums1\n        k = max(m, n)\n        ans = [0] * k\n        i = j = 0\n        for x in range(k):\n            a = -inf if i >= m else nums1[i]\n            b = -inf if j >= n else nums2[j]\n            if a > b:\n                ans[x] = nums1[i]\n                i += 1\n            elif a < b:\n                ans[x] = nums2[j]\n                j += 1\n            else:\n                cnt = 0\n                while i + cnt < m and j + cnt < n and nums1[i + cnt] == nums2[j + cnt]:\n                    cnt += 1\n                if i + cnt >= m or (j + cnt < n and nums2[j + cnt] > nums1[i + cnt]):\n                    ans[x] = nums2[j]\n                    j += 1\n                else:\n                    ans[x] = nums1[i]\n                    i += 1\n        return ans"
    },
    {
      "problem_id": "coin-change",
      "problem_title": "Coin Change",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": true,
      "total_tests": 127,
      "passed_tests": 127,
      "api_time": 16.44704794883728,
      "execution_time": 5.988585948944092,
      "error": null,
      "generated_code": "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        m, n = len(coins), amount\n        f = [[inf] * (n + 1) for _ in range(m + 1)]\n        f[0][0] = 0\n        for i, x in enumerate(coins, 1):\n            for j in range(n + 1):\n                f[i][j] = f[i - 1][j]\n                if j >= x:\n                    f[i][j] = min(f[i][j], f[i][j - x] + 1)\n        return -1 if f[m][n] == inf else f[m][n]"
    },
    {
      "problem_id": "largest-bst-subtree",
      "problem_title": "Largest Bst Subtree",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 120,
      "passed_tests": 0,
      "api_time": 25.279075860977173,
      "execution_time": 0.11148500442504883,
      "error": "Test execution error: 'list' object has no attribute 'left'\nTest execution error: 'str' object has no attribute 'left'\nTest execution error: 'str' object has no attribute 'left'\nTest execution error: 'str' object has no attribute 'left'\nTest execution error: 'str' object has no attribute 'left'\nTest execution error: 'list' object has no attribute 'left'\nTest execution error: 'str' object has no attribute 'left'\nTest execution error: 'list' object has no attribute 'left'\nTest execution error: 'li",
      "generated_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def largestBSTSubtree(self, root: Optional[TreeNode]) -> int:\n        def dfs(root):\n            if root is None:\n                return inf, -inf, 0\n            lmi, lmx, lsz = dfs(root.left)\n            rmi, rmx, rsz = dfs(root.right)\n            if not (lmi < root.val < lmx and rmi < root.val < rmx):\n                return -inf, inf, 0\n            nonlocal ans\n            sz = 1 + lsz + rsz\n            ans = max(ans, sz)\n            return min(lmi, root.val), max(root.val, rmx), sz\n\n        ans = 0\n        dfs(root)\n        return ans"
    },
    {
      "problem_id": "integer-break",
      "problem_title": "Integer Break",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": true,
      "total_tests": 30,
      "passed_tests": 30,
      "api_time": 10.596800088882446,
      "execution_time": 0.07192182540893555,
      "error": null,
      "generated_code": "class Solution:\n    def integerBreak(self, n: int) -> int:\n        f = [0] * (n + 1)\n        for i in range(2, n + 1):\n            for j in range(i - 1, 0, -1):\n                f[i] = max(f[i], max(j, f[j]) * max(i - j, f[i - j]))\n        return f[n]"
    },
    {
      "problem_id": "valid-word-abbreviation",
      "problem_title": "Valid Word Abbreviation",
      "difficulty": "Easy",
      "model": "deepseek-leetcode-p3",
      "passed": true,
      "total_tests": 234,
      "passed_tests": 234,
      "api_time": 21.326568126678467,
      "execution_time": 0.05695915222167969,
      "error": null,
      "generated_code": "class Solution:\n    def validWordAbbreviation(self, word: str, abbr: str) -> bool:\n        m, n = len(word), len(abbr)\n        i = j = cnt = 0\n        while i < m and j < n:\n            if abbr[j].isdigit():\n                if abbr[j] == '0' and cnt == 0:\n                    return False\n                cnt = cnt * 10 + int(abbr[j])\n            else:\n                i += cnt\n                cnt = 0\n                if i >= m or word[i] != abbr[j]:\n                    return False\n                i += 1\n            j += 1\n        return i + cnt == m and j == n"
    },
    {
      "problem_id": "strong-password-checker",
      "problem_title": "Strong Password Checker",
      "difficulty": "Hard",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 174,
      "passed_tests": 0,
      "api_time": 190.11855912208557,
      "execution_time": 0.07696104049682617,
      "error": null,
      "generated_code": "class Solution:\n    def strongPasswordChecker(self, password: str) -> int:\n        def f1():\n            return 6 <= len(password) <= 20\n\n        def f2():\n            return any(c.islower() for c in password)\n\n        def f3():\n            return any(c.isupper() for c in password)\n\n        def f4():\n            return any(c.isdigit() for c in password)\n\n        def f5():\n            s = set(\"abcdefghijklmnopqrstuvwxyz\")\n            for i in range(len(password) - 2):\n                if password[i] in s and password[i + 1] in s and password[i + 2] in s:\n                    return True\n            return False\n\n        def f6():\n            cnt = Counter()\n            for i, c in enumerate(password):\n                j = ord(c) - 97 if c.islower() else (ord(c) - 39 if c.isupper() else ord(c) - 21)\n                k = 0\n                while j and cnt[j] % 3 == 0:\n                    j >>= 1\n                    k += 1\n                cnt[j] += 1\n            return max(len(password) - 20, 3 - sum(v % 3 for v in cnt.values()))\n\n        def f7():\n            s = set(\"abcdefghijklmnopqrstuvwxyz\")\n            i = 0\n            while i < len(password):\n                j = i + 1\n                while j < len(password) and password[j] == password[i]:\n                    j += 1\n                if (ord(password[i]) - 97 in s or ord(password[i]) - 39 in s or ord(password[i]) - 21 in s) and j - i >= 3:\n                    return True\n                i = j\n            return False\n\n        def f8():\n            cnt = Counter()\n            for i, c in enumerate(password):\n                j = ord(c) - 97 if c.islower() else (ord(c) - 39 if c.isupper() else ord(c) - 21)\n                k = 0\n                while j and cnt[j] % 3 == 0:\n                    j >>= 1\n                    k += 1\n                cnt[j] += 1\n            return max(len(password) - 20, 3 - sum(v % 3 for v in cnt.values()))\n\n        def f9():\n            s = set(\"abcdefghijklmnopqrstuvwxyz\")\n            i = 0\n            while i < len(password):\n                j = i + 1\n                while j < len(password) and password[j] == password[i]:\n                    j += 1\n                if (ord(password[i]) - 97 in s or ord(password[i]) - 39 in s or ord(password[i]) - 21 in s) and j - i >= 3:\n                    return True\n                i = j\n            return False\n\n        def f10():\n            cnt = Counter()\n            for i, c in enumerate(password):\n                j = ord(c) - 97 if c.islower() else (ord(c) - 39 if c.isupper() else ord(c) - 21)\n                k = 0\n                while j and cnt[j] % 3 == 0:\n                    j >>= 1\n                    k += 1\n                cnt[j] += 1\n            return max(len(password) - 20, 3 - sum(v % 3 for v in cnt.values()))\n\n        def f11():\n            s = set(\"abcdefghijklmnopqrstuvwxyz\")\n            i = 0\n            while i < len(password):\n                j = i + 1\n                while j < len(password) and password[j] == password[i]:\n                    j += 1\n                if (ord(password[i]) - 97 in s or ord(password[i]) - 39 in s or ord(password[i]) - 21 in s) and j - i >= 3:\n                    return True\n                i = j\n            return False\n\n        def f12():\n            cnt = Counter()\n            for i, c in enumerate(password):\n                j = ord(c) - 97 if c.islower() else (ord(c) - 39 if c.isupper() else ord(c) - 21)\n                k = 0\n                while j and cnt[j] % 3 == 0:\n                    j >>= 1\n                    k += 1\n                cnt[j] += 1\n            return max(len(password) - 20, 3 - sum(v % 3 for v in cnt.values()))\n\n        def f13():\n            s = set(\"abcdefghijklmnopqrstuvwxyz\")\n            i = 0\n            while i < len(password):\n                j = i + 1\n                while j < len(password) and password[j] == password[i]:\n                    j += 1\n                if (ord(password[i]) - 97 in s or ord(password[i]) - 39 in s or ord(password[i]) - 21 in s) and j - i >= 3:\n                    return True\n                i = j\n            return False\n\n        def f14():\n            cnt = Counter()\n            for i, c in enumerate(password):\n                j = ord(c) - 97 if c.islower() else (ord(c) - 39 if c.isupper() else ord(c) - 21)\n                k = 0\n                while j and cnt[j] % 3 == 0:\n                    j >>= 1\n                    k += 1\n                cnt[j] += 1\n            return max(len(password) - 20, 3 - sum(v % 3 for v in cnt.values()))\n\n        def f15():\n            s = set(\"abcdefghijklmnopqrstuvwxyz\")\n            i = 0\n            while i < len(password):\n                j = i + 1\n                while j < len(password) and password[j] == password[i]:\n                    j += 1\n                if (ord(password[i]) - 97 in s or ord(password[i]) - 39 in s or ord(password[i]) - 21 in s) and j - i >= 3:\n                    return True\n                i = j\n            return False\n\n        def f16():\n            cnt = Counter()\n            for i, c in enumerate(password):\n                j = ord(c) - 97 if c.islower() else (ord(c) - 39 if c.isupper() else ord(c) - 21)\n                k = 0\n                while j and cnt[j] % 3 == 0:\n                    j >>= 1\n                    k += 1\n                cnt[j] += 1\n            return max(len(password) - 20, 3 - sum(v % 3 for v in cnt.values()))\n\n        def f17():\n            s = set(\"abcdefghijklmnopqrstuvwxyz\")\n            i = 0\n            while i < len(password):\n                j = i + 1\n                while j < len(password) and password[j] == password[i]:\n                    j += 1\n                if (ord(password[i]) - 97 in s or ord(password[i]) - 39 in s or ord(password[i]) - 21 in s) and j - i >= 3:\n                    return True\n                i = j\n            return False\n\n        def f18():\n            cnt = Counter()\n            for i, c in enumerate(password):\n                j = ord(c) - 97 if c.islower() else (ord(c) - 39 if c.isupper() else ord(c) - 21)\n                k = 0\n                while j and cnt[j] % 3 == 0:\n                    j >>= 1\n                    k += 1\n                cnt[j] += 1\n            return max(len(password) - 20, 3 - sum(v % 3 for v in cnt.values()))\n\n        def f19():\n            s = set(\"abcdefghijklmnopqrstuvwxyz\")\n            i = 0"
    },
    {
      "problem_id": "ones-and-zeroes",
      "problem_title": "Ones And Zeroes",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": true,
      "total_tests": 110,
      "passed_tests": 110,
      "api_time": 20.860156059265137,
      "execution_time": 0.0733938217163086,
      "error": null,
      "generated_code": "class Solution:\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\n        @cache\n        def dfs(i: int, j: int, k: int) -> int:\n            if i >= len(strs):\n                return 0\n            a = b = 0\n            for c in strs[i]:\n                if c == '0':\n                    a += 1\n                else:\n                    b += 1\n            ans = dfs(i + 1, j, k)\n            if a <= j and b <= k:\n                ans = max(ans, 1 + dfs(i + 1, j - a, k - b))\n            return ans\n\n        return dfs(0, m, n)"
    },
    {
      "problem_id": "coin-change-ii",
      "problem_title": "Coin Change Ii",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": true,
      "total_tests": 124,
      "passed_tests": 124,
      "api_time": 15.903190851211548,
      "execution_time": 0.24622797966003418,
      "error": null,
      "generated_code": "class Solution:\n    def change(self, amount: int, coins: List[int]) -> int:\n        m, n = len(coins), amount\n        f = [[0] * (n + 1) for _ in range(m + 1)]\n        f[0][0] = 1\n        for i, x in enumerate(coins, 1):\n            for j in range(n + 1):\n                f[i][j] = f[i - 1][j]\n                if j >= x:\n                    f[i][j] += f[i][j - x]\n        return f[m][n]"
    },
    {
      "problem_id": "diameter-of-binary-tree",
      "problem_title": "Diameter Of Binary Tree",
      "difficulty": "Easy",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 93,
      "passed_tests": 0,
      "api_time": 19.34392499923706,
      "execution_time": 0.0666799545288086,
      "error": "Test execution error: 'list' object has no attribute 'left'\nTest execution error: 'str' object has no attribute 'left'\nTest execution error: 'list' object has no attribute 'left'\nTest execution error: 'str' object has no attribute 'left'\nTest execution error: 'str' object has no attribute 'left'\nTest execution error: 'list' object has no attribute 'left'\nTest execution error: 'str' object has no attribute 'left'\nTest execution error: 'str' object has no attribute 'left'\nTest execution error: 'li",
      "generated_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\n        def dfs(root: Optional[TreeNode]) -> int:\n            if root is None:\n                return 0\n            l, r = dfs(root.left), dfs(root.right)\n            nonlocal ans\n            ans = max(ans, l + r + 1)\n            return 1 + max(l, r)\n\n        ans = 0\n        dfs(root)\n        return ans - 1"
    },
    {
      "problem_id": "subarray-sum-equals-k",
      "problem_title": "Subarray Sum Equals K",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": true,
      "total_tests": 102,
      "passed_tests": 102,
      "api_time": 9.673556089401245,
      "execution_time": 0.06728196144104004,
      "error": null,
      "generated_code": "class Solution:\n    def subarraySum(self, nums: List[int], k: int) -> int:\n        cnt = Counter({0: 1})\n        ans = s = 0\n        for x in nums:\n            s += x\n            ans += cnt[s - k]\n            cnt[s] += 1\n        return ans"
    },
    {
      "problem_id": "palindromic-substrings",
      "problem_title": "Palindromic Substrings",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": true,
      "total_tests": 140,
      "passed_tests": 140,
      "api_time": 15.020060777664185,
      "execution_time": 0.0815129280090332,
      "error": null,
      "generated_code": "class Solution:\n    def countSubstrings(self, s: str) -> int:\n        n = len(s)\n        f = [[True] * n for _ in range(n)]\n        ans = 0\n        for i in range(n - 1, -1, -1):\n            for j in range(i, n):\n                f[i][j] = s[i] == s[j] and (i + 1 >= j - 1 or f[i + 1][j - 1])\n                ans += int(f[i][j])\n        return ans"
    },
    {
      "problem_id": "two-sum-iv-input-is-a-bst",
      "problem_title": "Two Sum Iv Input Is A Bst",
      "difficulty": "Easy",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 89,
      "passed_tests": 0,
      "api_time": 19.941494941711426,
      "execution_time": 0.07168221473693848,
      "error": "Test execution error: 'str' object has no attribute 'val'\nTest execution error: 'str' object has no attribute 'val'\nTest execution error: 'list' object has no attribute 'val'\nTest execution error: 'list' object has no attribute 'val'\nTest execution error: 'list' object has no attribute 'val'\nTest execution error: 'list' object has no attribute 'val'\nTest execution error: 'list' object has no attribute 'val'\nTest execution error: 'list' object has no attribute 'val'\nTest execution error: 'str' ob",
      "generated_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findTarget(self, root: Optional[TreeNode], k: int) -> bool:\n        def dfs(root: Optional[TreeNode]) -> bool:\n            if root is None:\n                return False\n            if k - root.val in vis:\n                return True\n            vis.add(root.val)\n            return dfs(root.left) or dfs(root.right)\n\n        vis = set()\n        return dfs(root)"
    },
    {
      "problem_id": "maximum-sum-of-3-non-overlapping-subarrays",
      "problem_title": "Maximum Sum Of 3 Non Overlapping Subarrays",
      "difficulty": "Hard",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 80,
      "passed_tests": 0,
      "api_time": 30.45729899406433,
      "execution_time": 0.06916189193725586,
      "error": null,
      "generated_code": "class Solution:\n    def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        s1 = [0] * (n + 1)\n        for i, x in enumerate(nums):\n            s1[i + 1] = s1[i] + x\n        f = [[0, 0] for _ in range(n + 1)]\n        g = [[0, 0] for _ in range(n + 2)]\n        mx = 0\n        ans = [0, 0, 0]\n        for i in range(k, n - k * 2 + 1):\n            if f[i][0]:\n                continue\n            s = s1[i + k] - s1[i]\n            j = i - k * 2 + 1\n            while g[j][0] and (s + g[j][0]) > mx:\n                mx = s + g[j][0]\n                ans = [g[j][1], j, i]\n            if not f[i - k * 2 + 1][0]:\n                f[i] = [mx, ans[0]]\n        return ans"
    },
    {
      "problem_id": "longest-word-in-dictionary",
      "problem_title": "Longest Word In Dictionary",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 116,
      "passed_tests": 108,
      "api_time": 33.07151198387146,
      "execution_time": 0.06928873062133789,
      "error": null,
      "generated_code": "class TrieNode:\n  def __init__(self):\n    self.children = [None] * 26\n    self.isEndOfWord = False\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word):\n    node = self.root\n    for c in word:\n      index = ord(c) - ord('a')\n      if not node.children[index]:\n        node.children[index] = TrieNode()\n      node = node.children[index]\n    node.isEndOfWord = True\n\n  def search(self, word):\n    node = self.root\n    for c in word:\n      index = ord(c) - ord('a')\n      if not node.children[index]:\n        return False\n      node = node.children[index]\n      if not node.isEndOfWord:\n        return False\n    return True\n\n\nclass Solution:\n  def longestWord(self, words: List[str]) -> str:\n    trie = Trie()\n    for word in words:\n      trie.insert(word)\n\n    ans = ''\n    for word in words:\n      if len(ans) > len(word):\n        continue\n      if len(ans) == len(word) and ans >= word:\n        continue\n      if trie.search(word):\n        ans = word\n    return ans"
    },
    {
      "problem_id": "max-chunks-to-make-sorted-ii",
      "problem_title": "Max Chunks To Make Sorted Ii",
      "difficulty": "Hard",
      "model": "deepseek-leetcode-p3",
      "passed": true,
      "total_tests": 149,
      "passed_tests": 149,
      "api_time": 13.538141012191772,
      "execution_time": 0.0729069709777832,
      "error": null,
      "generated_code": "class Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stk = []\n        for v in arr:\n            if not stk or stk[-1] <= v:\n                stk.append(v)\n            else:\n                mx = stk.pop()\n                while stk and stk[-1] > v:\n                    stk.pop()\n                stk.append(mx)\n        return len(stk)"
    },
    {
      "problem_id": "basic-calculator-iv",
      "problem_title": "Basic Calculator Iv",
      "difficulty": "Hard",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 126,
      "passed_tests": 0,
      "api_time": 207.55050015449524,
      "execution_time": 0.11348819732666016,
      "error": "  File \"/var/folders/zf/_9clrgbj5txgck3v3jlfk8mc0000gn/T/tmp8vo08z4b.py\", line 98\n    return Term(), Term({}: int(token))\n                          ^\nSyntaxError: invalid syntax\n",
      "generated_code": "import re\nfrom typing import Dict, Tuple\n\nclass Term:\n    def __init__(self):\n        self.coeff = 0\n        self.vars = {}\n    \n    def add(self, other):\n        for var in other.vars:\n            if var not in self.vars:\n                self.vars[var] = other.vars[var]\n            else:\n                self.vars[var] += other.vars[var]\n        self.coeff += other.coeff\n    \n    def mul(self, other):\n        new_term = Term()\n        for var1 in self.vars:\n            for var2 in other.vars:\n                if (var1, var2) not in new_term.vars:\n                    new_term.vars[(var1, var2)] = self.vars[var1] * other.vars[var2]\n                else:\n                    new_term.vars[(var1, var2)] += self.vars[var1] * other.vars[var2]\n        for var in other.vars:\n            if var not in new_term.vars:\n                new_term.vars[var] = other.vars[var]\n            else:\n                new_term.vars[var] += other.vars[var]\n        new_term.coeff = self.coeff * other.coeff\n        return new_term\n    \n    def __str__(self):\n        if not self.vars and self.coeff == 0:\n            return \"0\"\n        \n        terms = []\n        for var in sorted(self.vars, key=lambda x: (len(x), x)):\n            coeff = self.vars[var]\n            if abs(coeff) != 1 or len(var) == 1:\n                terms.append(f\"{abs(coeff)}*{''.join(sorted(var))}\")\n            else:\n                terms.append(\"\".join(sorted(var)))\n        if self.coeff == -1 and terms:\n            terms[0] = \"-\" + terms[0]\n        elif self.coeff < 0:\n            terms[0] = f\"-{terms[0]}\"\n        \n        return \"+\".join(terms) or \"0\"\n    \n    def __eq__(self, other):\n        if not isinstance(other, Term):\n            return False\n        return self.coeff == other.coeff and self.vars == other.vars\n\nclass Solution:\n    def basicCalculatorIV(self, expression: str, evalvars: List[str], evalints: List[int]) -> List[str]:\n        # Step 1: Parse the input string into a list of tokens\n        token_regex = re.compile(r\"\\s*([\\(\\)+\\-*\\d]|[a-z]+|[a-z]*[a-z]\\w*)\\s*\")\n        tokens = [token for match in token_regex.finditer(expression) if (token := match.group())]\n        \n        # Step 2: Build the evaluation map from evalvars and evalints\n        evalmap = {var: int(val) for var, val in zip(evalvars, evalints)}\n        \n        def evaluate_term(token):\n            if token.isdigit():\n                return Term(), Term({}: int(token))\n            \n            term = Term()\n            if token[0].isalpha():\n                term.vars[tuple(sorted(token))] = 1\n            else:\n                coeff, rest_term = evaluate_term(token[1:])\n                term.coeff += int(token[0]) * coeff.coeff\n                for var in coeff.vars:\n                    if var not in term.vars:\n                        term.vars[var] = coeff.vars[var]\n                    else:\n                        term.vars[var] += coeff.vars[var]\n                \n                for var in rest_term.vars:\n                    if var not in term.vars:\n                        term.vars[var] = rest_term.vars[var]\n                    else:\n                        term.vars[var] += rest_term.vars[var]\n            \n            return term, Term()\n        \n        # Step 3: Process the tokens and build the final expression\n        stack = []\n        for token in tokens:\n            if token == \"(\":\n                stack.append([])\n            elif token == \")\":\n                inner_term = stack.pop()\n                outer_term = Term()\n                \n                while inner_term and isinstance(inner_term[-1], Term):\n                    outer_term.add(inner_term.pop())\n                \n                if inner_term:\n                    for var in inner_term[0].vars:\n                        if var not in outer_term.vars:\n                            outer_term.vars[var] = inner_term[0].vars[var]\n                        else:\n                            outer_term.vars[var] += inner_term[0].vars[var]\n                    del inner_term[0]\n                \n                if stack and isinstance(stack[-1], list):\n                    stack[-1].append(outer_term)\n                else:\n                    stack.append(outer_term)\n            elif token in \"+-\":\n                term = Term()\n                while stack and (isinstance(stack[-1], Term) or isinstance(stack[-1][0], Term)):\n                    if isinstance(stack[-1], Term):\n                        term.add(stack.pop())\n                    else:\n                        inner_term, rest_term = evaluate_term(token + stack.pop().pop())\n                        term.add(inner_term)\n                        while rest_term and (isinstance(rest_term[-1], Term) or isinstance(rest_term[-1][0], Term)):\n                            if isinstance(rest_term[-1], Term):\n                                term.add(rest_term.pop())\n                            else:\n                                inner_term, rest_term = evaluate_term(token + rest_term.pop().pop())\n                                term.add(inner_term)\n                        stack.append(rest_term)\n                if not isinstance(stack[-1], Term):\n                    stack[-1].append(term)\n            elif token == \"*\":\n                inner_term, rest_term = evaluate_term(stack.pop().pop())\n                outer_term = Term()\n                \n                while inner_term and (isinstance(inner_term[-1], Term) or isinstance(inner_term[-1][0], Term)):\n                    if isinstance(inner_term[-1], Term):\n                        outer_term.add(inner_term.pop())\n                    else:\n                        inner_term, rest_term = evaluate_term(\"*\" + inner_term.pop().pop())\n                        outer_term.add(inner_term)\n                        while rest_term and (isinstance(rest_term[-1], Term) or isinstance(rest_term[-1][0], Term)):\n                            if isinstance(rest_term[-1], Term):\n                                outer_term.add(rest_term.pop())\n                            else:\n                                inner_term, rest_term = evaluate_term(\"*\" + rest_term.pop().pop())\n                                outer_term.add(inner_term)\n                        stack.append(rest_term)\n                if not isinstance(stack[-1], Term):\n                    stack[-1].append(outer_term)\n                \n                term = inner_term\n                while rest_term and (isinstance(rest_term[-1], Term) or isinstance(rest_term[-1][0], Term)):\n                    if isinstance(rest_term[-1], Term):\n                        term.add(rest_term.pop())\n                    else:\n                        inner_term, rest_term = evaluate_term(\"*\" + rest_term.pop().pop())\n                        term.add(inner_term)\n                stack.append(rest_term)\n                \n                if not isinstance(stack[-1], Term):\n                    stack[-1].append(term)\n            else:\n                # Evaluate the token as a variable or constant\n                coeff, rest_term = evaluate_term(token)\n                term = Term()\n                for var in coeff.vars:\n                    if var not in term.vars:\n                        term.vars[var] = coeff.vars[var] * evalmap.get(var, 1)\n                    else:\n                        term.vars[var] += coeff.vars[var] * evalmap.get(var, 1)\n                while rest_term and (isinstance(rest_term[-1], Term) or isinstance(rest_term[-1][0], Term)):\n                    if isinstance(rest_term[-1], Term):\n                        term.add(rest_term."
    },
    {
      "problem_id": "similar-rgb-color",
      "problem_title": "Similar Rgb Color",
      "difficulty": "Easy",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 167,
      "passed_tests": 0,
      "api_time": 15.201722145080566,
      "execution_time": 0.07278895378112793,
      "error": "Test execution error: string index out of range\nTest execution error: string index out of range\nTest execution error: string index out of range\nTest execution error: string index out of range\nTest execution error: string index out of range\nTest execution error: string index out of range\nTest execution error: string index out of range\nTest execution error: string index out of range\nTest execution error: string index out of range\nTest execution error: string index out of range\nTest execution error",
      "generated_code": "class Solution:\n    def similarRGB(self, color: str) -> str:\n        def f(c):\n            x = int(c[1] + c[2], 16)\n            a = min(range(17), key=lambda i: abs(i * 17 - x))\n            return c[0] + hex(a * 17)[2:]\n\n        return '#' + f(color[1 : 3]) + f(color[3 : 5]) + f(color[5 : 7])"
    },
    {
      "problem_id": "push-dominoes",
      "problem_title": "Push Dominoes",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 162,
      "passed_tests": 5,
      "api_time": 24.784921884536743,
      "execution_time": 0.07541394233703613,
      "error": null,
      "generated_code": "class Solution:\n    def pushDominoes(self, dominoes: str) -> str:\n        n = len(dominoes)\n        q = deque()\n        time = [-1] * n\n        force = [0] * n\n        for i, f in enumerate(dominoes):\n            if f != '.':\n                q.append(i)\n                time[i] = 0\n                force[i] = -1 if f == 'L' else 1\n        ans = ['.'] * n\n        while q:\n            i = q.popleft()\n            j = i + force[i]\n            if 0 <= j < n and time[j] == -1:\n                time[j] = time[i] + 1\n                force[j] = force[i]\n                ans[j] = 'L' if force[j] < 0 else 'R'\n                q.append(j)\n        return ''.join(ans)"
    },
    {
      "problem_id": "leaf-similar-trees",
      "problem_title": "Leaf Similar Trees",
      "difficulty": "Easy",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 88,
      "passed_tests": 0,
      "api_time": 17.99319100379944,
      "execution_time": 0.0673680305480957,
      "error": "Test execution error: 'list' object has no attribute 'left'\nTest execution error: 'str' object has no attribute 'left'\nTest execution error: 'str' object has no attribute 'left'\nTest execution error: 'str' object has no attribute 'left'\nTest execution error: 'str' object has no attribute 'left'\nTest execution error: 'str' object has no attribute 'left'\nTest execution error: 'str' object has no attribute 'left'\nTest execution error: 'str' object has no attribute 'left'\nTest execution error: 'str'",
      "generated_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def leafSimilar(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:\n        def dfs(root):\n            if root is None:\n                return []\n            if root.left == root.right:\n                return [root.val]\n            return dfs(root.left) + dfs(root.right)\n\n        return dfs(root1) == dfs(root2)"
    },
    {
      "problem_id": "length-of-longest-fibonacci-subsequence",
      "problem_title": "Length Of Longest Fibonacci Subsequence",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 122,
      "passed_tests": 105,
      "api_time": 18.964462995529175,
      "execution_time": 0.07099390029907227,
      "error": null,
      "generated_code": "class Solution:\n    def lenLongestFibSubseq(self, arr: List[int]) -> int:\n        n = len(arr)\n        f = [[0] * n for _ in range(n)]\n        d = {x: i for i, x in enumerate(arr)}\n        ans = 0\n        for i in range(2, n):\n            for j in range(1, i):\n                k = d.get(arr[i] - arr[j], -1)\n                if k >= 0:\n                    f[j][i] = max(f[k][j] + 1, 3)\n                    ans = max(ans, f[j][i])\n        return ans"
    },
    {
      "problem_id": "validate-stack-sequences",
      "problem_title": "Validate Stack Sequences",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": true,
      "total_tests": 101,
      "passed_tests": 101,
      "api_time": 11.537061214447021,
      "execution_time": 0.07311201095581055,
      "error": null,
      "generated_code": "class Solution:\n    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:\n        stk = []\n        i = 0\n        for x in pushed:\n            stk.append(x)\n            while stk and stk[-1] == popped[i]:\n                stk.pop()\n                i += 1\n        return not stk"
    },
    {
      "problem_id": "largest-time-for-given-digits",
      "problem_title": "Largest Time For Given Digits",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 123,
      "passed_tests": 18,
      "api_time": 21.770347118377686,
      "execution_time": 0.06762123107910156,
      "error": null,
      "generated_code": "class Solution:\n    def largestTimeFromDigits(self, arr: List[int]) -> str:\n        ans = -1\n        for i in range(4):\n            for j in range(4):\n                if i != j:\n                    a, b, c, d = (\n                        arr[(i + 1) % 4],\n                        arr[(i + 2) % 4],\n                        arr[(j + 1) % 4],\n                        arr[(j + 2) % 4],\n                    )\n                    t = 60 * 10 * a + b + 60 * c + 10 * d + d\n                    if ans < t <= 2359:\n                        ans = t\n        return \"\" if ans == -1 else f\"{ans // 60:02}:{ans % 60:02}\""
    },
    {
      "problem_id": "find-common-characters",
      "problem_title": "Find Common Characters",
      "difficulty": "Easy",
      "model": "deepseek-leetcode-p3",
      "passed": true,
      "total_tests": 103,
      "passed_tests": 103,
      "api_time": 10.158674240112305,
      "execution_time": 0.07188701629638672,
      "error": null,
      "generated_code": "class Solution:\n    def commonChars(self, words: List[str]) -> List[str]:\n        cnt = Counter(words[0])\n        for s in words[1:]:\n            t = Counter(s)\n            for c, v in cnt.items():\n                cnt[c] = min(v, t[c])\n        return list(cnt.elements())"
    },
    {
      "problem_id": "binary-prefix-divisible-by-5",
      "problem_title": "Binary Prefix Divisible By 5",
      "difficulty": "Easy",
      "model": "deepseek-leetcode-p3",
      "passed": true,
      "total_tests": 69,
      "passed_tests": 69,
      "api_time": 10.755156993865967,
      "execution_time": 0.05159401893615723,
      "error": null,
      "generated_code": "class Solution:\n    def prefixesDivBy5(self, nums: List[int]) -> List[bool]:\n        ans = []\n        x = 0\n        for v in nums:\n            x = (x << 1 | v) % 5\n            ans.append(x == 0)\n        return ans"
    },
    {
      "problem_id": "longest-arithmetic-subsequence",
      "problem_title": "Longest Arithmetic Subsequence",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 175,
      "passed_tests": 159,
      "api_time": 17.101398229599,
      "execution_time": 0.07317996025085449,
      "error": "Test execution error: list index out of range\nTest execution error: list index out of range\nTest execution error: list index out of range\nTest execution error: list index out of range\nTest execution error: list index out of range\nTest execution error: list index out of range\nTest execution error: list index out of range\nTest execution error: list index out of range\nTest execution error: list index out of range\nTest execution error: list index out of range\nTest execution error: list index out of ",
      "generated_code": "class Solution:\n    def longestArithSeqLength(self, nums: List[int]) -> int:\n        n = len(nums)\n        f = [[1] * 1001 for _ in range(n)]\n        ans = 2\n        for i in range(1, n):\n            for j in range(i):\n                d = nums[i] - nums[j] + 500\n                f[i][d] = max(f[i][d], f[j][d] + 1)\n                ans = max(ans, f[i][d])\n        return ans"
    },
    {
      "problem_id": "recover-a-tree-from-preorder-traversal",
      "problem_title": "Recover A Tree From Preorder Traversal",
      "difficulty": "Hard",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 188,
      "passed_tests": 0,
      "api_time": 27.62148928642273,
      "execution_time": 0.06082415580749512,
      "error": "Test execution error: list index out of range\nTest execution error: list index out of range\nTest execution error: list index out of range\nTest execution error: list index out of range\nTest execution error: list index out of range\nTest execution error: list index out of range\nTest execution error: list index out of range\nTest execution error: list index out of range\nTest execution error: list index out of range\nTest execution error: list index out of range\nTest execution error: list index out of ",
      "generated_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:\n        stk = []\n        i, n = 0, len(traversal)\n        while i < n:\n            depth = 0\n            while traversal[i] == '-':\n                depth += 1\n                i += 1\n            val = 0\n            while i < n and traversal[i].isdigit():\n                val = val * 10 + int(traversal[i])\n                i += 1\n            node = TreeNode(val)\n            if depth == len(stk):\n                stk[-1].left = node\n            else:\n                stk = stk[:depth]\n                stk[-1].right = node\n            stk.append(node)\n        return stk[0]"
    },
    {
      "problem_id": "maximum-sum-of-two-non-overlapping-subarrays",
      "problem_title": "Maximum Sum Of Two Non Overlapping Subarrays",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 110,
      "passed_tests": 42,
      "api_time": 20.85077714920044,
      "execution_time": 0.07037091255187988,
      "error": null,
      "generated_code": "class Solution:\n    def maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:\n        n = len(nums)\n        s = list(accumulate(nums, initial=0))\n        ans = t = 0\n        for i in range(firstLen + secondLen, n + 1):\n            j = i - firstLen\n            k = i - secondLen\n            t = max(t, s[j] - s[j - firstLen])\n            x = s[i] - s[i - secondLen]\n            y = s[k] - s[k - firstLen]\n            ans = max(ans, t + x, t + y)\n        return ans"
    },
    {
      "problem_id": "robot-bounded-in-circle",
      "problem_title": "Robot Bounded In Circle",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": true,
      "total_tests": 140,
      "passed_tests": 140,
      "api_time": 26.42745614051819,
      "execution_time": 0.05808091163635254,
      "error": null,
      "generated_code": "class Solution:\n    def isRobotBounded(self, instructions: str) -> bool:\n        dirs = (0, 1, 2, 3)\n        x = y = 0\n        d = 0\n        for c in instructions * 4:\n            if c == \"L\":\n                d = dirs[(d + 3) % 4]\n            elif c == \"R\":\n                d = dirs[(d + 1) % 4]\n            else:\n                match d:\n                    case 0:\n                        y += 1\n                    case 1:\n                        x -= 1\n                    case 2:\n                        y -= 1\n                    case 3:\n                        x += 1\n        return (x, y) == (0, 0)"
    },
    {
      "problem_id": "confusing-number",
      "problem_title": "Confusing Number",
      "difficulty": "Easy",
      "model": "deepseek-leetcode-p3",
      "passed": true,
      "total_tests": 131,
      "passed_tests": 131,
      "api_time": 16.395628929138184,
      "execution_time": 0.06054210662841797,
      "error": null,
      "generated_code": "class Solution:\n    def confusingNumber(self, n: int) -> bool:\n        x, y = n, 0\n        d = (0, 1, -1, -1, -1, -1, 9, -1, 8, 6)\n        while x:\n            x, v = divmod(x, 10)\n            if d[v] < 0:\n                return False\n            y = y * 10 + d[v]\n        return n != y"
    },
    {
      "problem_id": "corporate-flight-bookings",
      "problem_title": "Corporate Flight Bookings",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 110,
      "passed_tests": 109,
      "api_time": 15.823589086532593,
      "execution_time": 0.06318116188049316,
      "error": null,
      "generated_code": "class Solution:\n    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:\n        ans = [0] * (n + 1)\n        for first, last, seats in bookings:\n            ans[first - 1] += seats\n            ans[last] -= seats\n        return list(accumulate(ans))[:-1]"
    },
    {
      "problem_id": "maximum-average-subtree",
      "problem_title": "Maximum Average Subtree",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 88,
      "passed_tests": 0,
      "api_time": 23.142009019851685,
      "execution_time": 0.06851911544799805,
      "error": "Test execution error: 'list' object has no attribute 'left'\nTest execution error: 'str' object has no attribute 'left'\nTest execution error: 'list' object has no attribute 'left'\nTest execution error: 'str' object has no attribute 'left'\nTest execution error: 'str' object has no attribute 'left'\nTest execution error: 'str' object has no attribute 'left'\nTest execution error: 'list' object has no attribute 'left'\nTest execution error: 'list' object has no attribute 'left'\nTest execution error: 'l",
      "generated_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maximumAverageSubtree(self, root: Optional[TreeNode]) -> float:\n        def dfs(root):\n            if root is None:\n                return 0, 0\n            ls, ln = dfs(root.left)\n            rs, rn = dfs(root.right)\n            s = root.val + ls + rs\n            n = 1 + ln + rn\n            nonlocal ans\n            ans = max(ans, s / n)\n            return s, n\n\n        ans = 0\n        dfs(root)\n        return ans"
    },
    {
      "problem_id": "minimum-cost-tree-from-leaf-values",
      "problem_title": "Minimum Cost Tree From Leaf Values",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": true,
      "total_tests": 108,
      "passed_tests": 108,
      "api_time": 19.786325931549072,
      "execution_time": 0.07752823829650879,
      "error": null,
      "generated_code": "class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        @cache\n        def dfs(i: int, j: int) -> Tuple[int, int]:\n            if i == j:\n                return 0, arr[i]\n            s = inf\n            mx = 0\n            for k in range(i, j):\n                l, x = dfs(i, k)\n                r, y = dfs(k + 1, j)\n                t = l + r + x * y\n                if s > t:\n                    s = t\n                    mx = max(x, y)\n            return s, mx\n\n        return dfs(0, len(arr) - 1)[0]"
    },
    {
      "problem_id": "decrease-elements-to-make-array-zigzag",
      "problem_title": "Decrease Elements To Make Array Zigzag",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 148,
      "passed_tests": 14,
      "api_time": 10.38993787765503,
      "execution_time": 0.06643509864807129,
      "error": null,
      "generated_code": "class Solution:\n    def movesToMakeZigzag(self, nums: List[int]) -> int:\n        def f(k):\n            return sum(max(0, a - b + 1) for a, b in pairwise(nums[::k]))\n\n        return min(f(1), f(-1))"
    },
    {
      "problem_id": "longest-chunked-palindrome-decomposition",
      "problem_title": "Longest Chunked Palindrome Decomposition",
      "difficulty": "Hard",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 181,
      "passed_tests": 11,
      "api_time": 18.906434059143066,
      "execution_time": 0.06710028648376465,
      "error": null,
      "generated_code": "class Solution:\n    def longestDecomposition(self, text: str) -> int:\n        n = len(text)\n        ans = 0\n        i, j = 0, n\n        while i < j:\n            k = 1\n            ok = False\n            while i + k <= j - k + 1:\n                if text[i : i + k] == text[j - k + 1 : j + 1]:\n                    ans += 2\n                    i, j = i + k, j - k\n                    ok = True\n                    break\n                k += 1\n            if not ok:\n                return 1\n        return ans"
    },
    {
      "problem_id": "make-array-strictly-increasing",
      "problem_title": "Make Array Strictly Increasing",
      "difficulty": "Hard",
      "model": "deepseek-leetcode-p3",
      "passed": true,
      "total_tests": 145,
      "passed_tests": 145,
      "api_time": 24.236539840698242,
      "execution_time": 0.06490492820739746,
      "error": null,
      "generated_code": "class Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        @cache\n        def dfs(i: int, pre: int) -> int:\n            if i >= n:\n                return 0\n            j = bisect_right(arr2, pre)\n            ans = 1 << 30\n            if arr1[i] > pre:\n                ans = min(ans, dfs(i + 1, arr1[i]))\n            if j < m:\n                ans = min(ans, 1 + dfs(i + 1, arr2[j]))\n            return ans\n\n        n, m = len(arr1), len(arr2)\n        arr2.sort()\n        ans = dfs(0, -1)\n        return -1 if ans >= 1 << 30 else ans"
    },
    {
      "problem_id": "two-sum-bsts",
      "problem_title": "Two Sum Bsts",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 100,
      "passed_tests": 0,
      "api_time": 28.23457407951355,
      "execution_time": 0.05909991264343262,
      "error": "Test execution error: 'list' object has no attribute 'val'\nTest execution error: 'list' object has no attribute 'val'\nTest execution error: 'list' object has no attribute 'val'\nTest execution error: 'list' object has no attribute 'val'\nTest execution error: 'list' object has no attribute 'val'\nTest execution error: 'list' object has no attribute 'val'\nTest execution error: 'list' object has no attribute 'val'\nTest execution error: 'list' object has no attribute 'val'\nTest execution error: 'list'",
      "generated_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def twoSumBSTs(\n        self, root1: Optional[TreeNode], root2: Optional[TreeNode], target: int\n    ) -> bool:\n        def dfs(root: Optional[TreeNode]) -> bool:\n            if root is None:\n                return False\n            x = target - root.val\n            return (x in vis) or dfs(root.left) or dfs(root.right)\n\n        vis = set()\n        q = deque([root1])\n        while q:\n            node = q.popleft()\n            vis.add(node.val)\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n        return dfs(root2)"
    },
    {
      "problem_id": "greatest-sum-divisible-by-three",
      "problem_title": "Greatest Sum Divisible By Three",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": true,
      "total_tests": 139,
      "passed_tests": 139,
      "api_time": 11.711910963058472,
      "execution_time": 0.07544827461242676,
      "error": null,
      "generated_code": "class Solution:\n    def maxSumDivThree(self, nums: List[int]) -> int:\n        f = [0] * 3\n        for x in nums:\n            for y in f[:]:\n                f[(x + y) % 3] = max(f[(x + y) % 3], x + y)\n        return f[0]"
    },
    {
      "problem_id": "find-winner-on-a-tic-tac-toe-game",
      "problem_title": "Find Winner On A Tic Tac Toe Game",
      "difficulty": "Easy",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 114,
      "passed_tests": 24,
      "api_time": 28.637717962265015,
      "execution_time": 0.06378293037414551,
      "error": null,
      "generated_code": "class Solution:\n    def tictactoe(self, moves: List[List[int]]) -> str:\n        g = [[0] * 3 for _ in range(3)]\n        p = 1\n        for i, j in moves:\n            g[i][j] = p\n            p ^= 3\n        for row in g:\n            if s := sum(row):\n                return \"A\" if s == 3 else \"B\"\n        for j in range(3):\n            if s := sum(g[i][j] for i in range(3)):\n                return \"A\" if s == 3 else \"B\"\n        if s := sum(g[i][i] for i in range(3)):\n            return \"A\" if s == 3 else \"B\"\n        if s := sum(g[i][2 - i] for i in range(3)):\n            return \"A\" if s == 3 else \"B\"\n        return \"Draw\" if len(moves) == 9 else \"Pending\""
    },
    {
      "problem_id": "sum-of-mutated-array-closest-to-target",
      "problem_title": "Sum Of Mutated Array Closest To Target",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 113,
      "passed_tests": 29,
      "api_time": 16.336631059646606,
      "execution_time": 0.9550392627716064,
      "error": null,
      "generated_code": "class Solution:\n    def findBestValue(self, arr: List[int], target: int) -> int:\n        arr.sort()\n        s = list(accumulate(arr, initial=0))\n        n = len(arr)\n        diff = inf\n        ans = 0\n        for v in range(max(arr) + 1):\n            i = bisect_right(arr, v)\n            cur = abs((s[n] - s[i]) - (n - i) * v)\n            if diff > cur:\n                diff = cur\n                ans = v\n        return ans"
    },
    {
      "problem_id": "count-negative-numbers-in-a-sorted-matrix",
      "problem_title": "Count Negative Numbers In A Sorted Matrix",
      "difficulty": "Easy",
      "model": "deepseek-leetcode-p3",
      "passed": true,
      "total_tests": 96,
      "passed_tests": 96,
      "api_time": 12.463932991027832,
      "execution_time": 0.06376409530639648,
      "error": null,
      "generated_code": "class Solution:\n    def countNegatives(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        i, j = m - 1, 0\n        ans = 0\n        while i >= 0 and j < n:\n            if grid[i][j] < 0:\n                ans += n - j\n                i -= 1\n            else:\n                j += 1\n        return ans"
    },
    {
      "problem_id": "counting-elements",
      "problem_title": "Counting Elements",
      "difficulty": "Easy",
      "model": "deepseek-leetcode-p3",
      "passed": true,
      "total_tests": 125,
      "passed_tests": 125,
      "api_time": 7.144323825836182,
      "execution_time": 0.06229996681213379,
      "error": null,
      "generated_code": "class Solution:\n    def countElements(self, arr: List[int]) -> int:\n        cnt = Counter(arr)\n        return sum(v for x, v in cnt.items() if x + 1 in cnt)"
    },
    {
      "problem_id": "least-number-of-unique-integers-after-k-removals",
      "problem_title": "Least Number Of Unique Integers After K Removals",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": true,
      "total_tests": 69,
      "passed_tests": 69,
      "api_time": 10.691910982131958,
      "execution_time": 0.05962228775024414,
      "error": null,
      "generated_code": "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        cnt = Counter(arr)\n        for i, v in enumerate(sorted(cnt.values())):\n            if (k := k - v) < 0:\n                return len(cnt) - i\n        return 0"
    },
    {
      "problem_id": "put-boxes-into-the-warehouse-i",
      "problem_title": "Put Boxes Into The Warehouse I",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 107,
      "passed_tests": 75,
      "api_time": 24.599457025527954,
      "execution_time": 0.06293821334838867,
      "error": null,
      "generated_code": "class Solution:\n    def maxBoxesInWarehouse(self, boxes: List[int], warehouse: List[int]) -> int:\n        n = len(warehouse)\n        left = [0] * n\n        right = [0] * n\n        mi = 1 << 31\n        for i in range(n):\n            mi = min(mi, warehouse[i])\n            left[i] = mi\n        mi = 1 << 31\n        for i in range(n - 1, -1, -1):\n            mi = min(mi, warehouse[i])\n            right[i] = mi\n        boxes.sort()\n        j = 0\n        ans = 0\n        for h in left:\n            while j < len(boxes) and boxes[j] > h:\n                j += 1\n            if j == len(boxes):\n                break\n            ans, j = ans + 1, j + 1\n        return ans"
    },
    {
      "problem_id": "minimum-number-of-removals-to-make-mountain-array",
      "problem_title": "Minimum Number Of Removals To Make Mountain Array",
      "difficulty": "Hard",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 115,
      "passed_tests": 107,
      "api_time": 20.055399179458618,
      "execution_time": 0.06543326377868652,
      "error": "Test execution error: max() iterable argument is empty\nTest execution error: max() iterable argument is empty\nTest execution error: max() iterable argument is empty\nTest execution error: max() iterable argument is empty\nTest execution error: max() iterable argument is empty\nTest execution error: max() iterable argument is empty\nTest execution error: max() iterable argument is empty\nTest execution error: max() iterable argument is empty\n",
      "generated_code": "class Solution:\n    def minimumMountainRemovals(self, nums: List[int]) -> int:\n        n = len(nums)\n        f = [1] * n\n        g = [1] * n\n        for i in range(n):\n            for j in range(i):\n                if nums[j] < nums[i]:\n                    f[i] = max(f[i], f[j] + 1)\n        for i in range(n - 1, -1, -1):\n            for j in range(n - 1, i, -1):\n                if nums[j] < nums[i]:\n                    g[i] = max(g[i], g[j] + 1)\n        return n - max(a + b - 1 for a, b in zip(f, g) if a > 1 and b > 1)"
    },
    {
      "problem_id": "maximum-value-at-a-given-index-in-a-bounded-array",
      "problem_title": "Maximum Value At A Given Index In A Bounded Array",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 92,
      "passed_tests": 68,
      "api_time": 21.22095012664795,
      "execution_time": 0.06089329719543457,
      "error": null,
      "generated_code": "class Solution:\n    def maxValue(self, n: int, index: int, maxSum: int) -> int:\n        def f(x):\n            a = b = 1\n            if x > index + 1:\n                a = (x + x - index - 1) * (index + 1) // 2\n            else:\n                a = (1 + x) * x // 2 + index + 1 - x\n            if x > n - index:\n                b = (x + x - n + index) * (n - index) // 2\n            else:\n                b = (1 + x) * x // 2 + n - index - x\n            return a + b - x\n\n        l, r = 0, maxSum + 1\n        while l < r:\n            mid = (l + r) >> 1\n            if f(mid) <= maxSum:\n                l = mid + 1\n            else:\n                r = mid\n        return l - 1"
    },
    {
      "problem_id": "remove-duplicates-from-an-unsorted-linked-list",
      "problem_title": "Remove Duplicates From An Unsorted Linked List",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 77,
      "passed_tests": 0,
      "api_time": 18.95063805580139,
      "execution_time": 0.06152606010437012,
      "error": "Test execution error: 'list' object has no attribute 'val'\nTest execution error: 'list' object has no attribute 'val'\nTest execution error: 'list' object has no attribute 'val'\nTest execution error: 'list' object has no attribute 'val'\nTest execution error: 'list' object has no attribute 'val'\nTest execution error: 'list' object has no attribute 'val'\nTest execution error: 'list' object has no attribute 'val'\nTest execution error: 'list' object has no attribute 'val'\nTest execution error: 'list'",
      "generated_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def deleteDuplicatesUnsorted(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        cnt = Counter()\n        cur = head\n        while cur:\n            cnt[cur.val] += 1\n            cur = cur.next\n        dummy = ListNode(-1, head)\n        pre, cur = dummy, head\n        while cur:\n            if cnt[cur.val] > 1:\n                pre.next = cur.next\n            else:\n                pre = cur\n            cur = cur.next\n        return dummy.next"
    },
    {
      "problem_id": "minimum-cost-to-change-the-final-value-of-expression",
      "problem_title": "Minimum Cost To Change The Final Value Of Expression",
      "difficulty": "Hard",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 173,
      "passed_tests": 0,
      "api_time": 25.050588846206665,
      "execution_time": 0.06221795082092285,
      "error": "Test execution error: too many values to unpack (expected 2, got 4)\nTest execution error: too many values to unpack (expected 2, got 4)\nTest execution error: too many values to unpack (expected 2, got 4)\nTest execution error: too many values to unpack (expected 2, got 4)\nTest execution error: too many values to unpack (expected 2, got 4)\nTest execution error: too many values to unpack (expected 2, got 4)\nTest execution error: too many values to unpack (expected 2, got 4)\nTest execution error: to",
      "generated_code": "class Solution:\n    def minOperationsToFlip(self, expression: str) -> int:\n        @cache\n        def dfs(exp):\n            if exp.count(\"0\") == len(exp):\n                return 1, 0\n            if exp.count(\"1\") == len(exp):\n                return 0, 1\n            ans = inf, inf\n            for i in range(len(exp)):\n                c = exp[i]\n                if c not in \"&|\":\n                    continue\n                a, b = dfs(exp[:i]) + dfs(exp[i + 1 :])\n                if c == \"&\":\n                    ans = min(ans, (a, b), key=lambda x: x[0] or x[1])\n                else:\n                    ans = min(ans, (a, b), key=lambda x: x[0] and x[1])\n            return ans\n\n        a, b = dfs(expression)\n        return min(a, b)"
    },
    {
      "problem_id": "maximum-of-minimum-values-in-all-subarrays",
      "problem_title": "Maximum Of Minimum Values In All Subarrays",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 140,
      "passed_tests": 15,
      "api_time": 30.96734380722046,
      "execution_time": 0.06593108177185059,
      "error": null,
      "generated_code": "class Solution:\n    def findMaximums(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        left = [-1] * n\n        right = [n] * n\n        stk = []\n        for i in range(n):\n            while stk and nums[stk[-1]] >= nums[i]:\n                stk.pop()\n            if stk:\n                left[i] = stk[-1]\n            stk.append(i)\n        stk = []\n        for i in range(n - 1, -1, -1):\n            while stk and nums[stk[-1]] >= nums[i]:\n                stk.pop()\n            if stk:\n                right[i] = stk[-1]\n            stk.append(i)\n        ans = [0] * n\n        for i in range(n):\n            l, r = left[i], right[i]\n            mx = max(ans[: i + 1]) if i > 0 else 0\n            length = r - l - 1\n            ans[length - 1] = max(ans[length - 1], nums[i], mx)\n        return ans"
    },
    {
      "problem_id": "maximum-product-of-the-length-of-two-palindromic-substrings",
      "problem_title": "Maximum Product Of The Length Of Two Palindromic Substrings",
      "difficulty": "Hard",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 173,
      "passed_tests": 0,
      "api_time": 20.641685009002686,
      "execution_time": 30.012449026107788,
      "error": "Timeout after 30 seconds",
      "generated_code": "class Solution:\n  def maxProduct(self, s: str) -> int:\n    n = len(s)\n    # dp[mask] := the length of the longest palindromic subsequence in s with mask.\n    dp = [0] * (1 << n)\n\n    for i in range(n):\n      for mask in range((1 << n) - 1, 0, -1):\n        if mask >> i & 1:\n          # If the current character is different from s[i], then we can't use it.\n          if s[i] != s[(n - 1) ^ i]:\n            continue\n          dp[mask] = max(dp[mask], dp[mask ^ (1 << i)] + 2)\n    return max((a + b for a in dp for b in dp if not (a & b)), default=0)"
    },
    {
      "problem_id": "minimum-number-of-swaps-to-make-the-string-balanced",
      "problem_title": "Minimum Number Of Swaps To Make The String Balanced",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 114,
      "passed_tests": 4,
      "api_time": 9.252243995666504,
      "execution_time": 0.06080818176269531,
      "error": null,
      "generated_code": "class Solution:\n    def minSwaps(self, s: str) -> int:\n        ans = cnt = 0\n        for c in s:\n            if c == '[':\n                cnt += 1\n            elif cnt:\n                cnt -= 1\n                ans += 1\n        return ans"
    },
    {
      "problem_id": "last-day-where-you-can-still-cross",
      "problem_title": "Last Day Where You Can Still Cross",
      "difficulty": "Hard",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 54,
      "passed_tests": 0,
      "api_time": 54.19337296485901,
      "execution_time": 0.06970381736755371,
      "error": null,
      "generated_code": "class UnionFind:\n    __slots__ = \"p\", \"size\"\n\n    def __init__(self, n):\n        self.p = list(range(n))\n        self.size = [1] * n\n\n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n\n    def union(self, a, b):\n        pa, pb = self.find(a), self.find(b)\n        if pa == pb:\n            return False\n        if self.size[pa] > self.size[pb]:\n            self.p[pb] = pa\n            self.size[pa] += self.size[pb]\n        else:\n            self.p[pa] = pb\n            self.size[pb] += self.size[pa]\n        return True\n\n    def connected(self, a, b):\n        return self.find(a) == self.find(b)\n\n\nclass Solution:\n    def latestDayToCross(self, row: int, col: int, cells: List[List[int]]) -> int:\n        n = row * col\n        uf = UnionFind(n + 2)\n        grid = [[0] * col for _ in range(row)]\n        dirs = (1, 0, -1, 0, 1)\n        for i, (x, y) in enumerate(cells):\n            x, y = x - 1, y - 1\n            grid[x][y] = 1\n            for a, b in pairwise(dirs):\n                nx, ny = x + a, y + b\n                if (\n                    0 <= nx < row\n                    and 0 <= ny < col\n                    and grid[nx][ny] == 1\n                    and uf.connected(nx * col + ny + 1, n) == False\n                ):\n                    uf.union(nx * col + ny + 1, x * col + y + 1)\n            if i > 0 and grid[cells[i - 1][0] - 1][cells[i - 1][1] - 1] == 0:\n                uf.union(n, cells[i - 1][0] * col + cells[i - 1][1])\n            if uf.connected(0, n) == True:\n                return i\n        return len(cells)"
    },
    {
      "problem_id": "remove-colored-pieces-if-both-neighbors-are-the-same-color",
      "problem_title": "Remove Colored Pieces If Both Neighbors Are The Same Color",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": true,
      "total_tests": 182,
      "passed_tests": 182,
      "api_time": 13.500048160552979,
      "execution_time": 0.06548619270324707,
      "error": null,
      "generated_code": "class Solution:\n    def winnerOfGame(self, colors: str) -> bool:\n        a = b = 0\n        for c, v in groupby(colors):\n            x = len(list(v)) - 2\n            if x > 0 and c == \"A\":\n                a += x\n            elif x > 0 and c == \"B\":\n                b += x\n        return a > b"
    },
    {
      "problem_id": "count-good-triplets-in-an-array",
      "problem_title": "Count Good Triplets In An Array",
      "difficulty": "Hard",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 102,
      "passed_tests": 27,
      "api_time": 32.57080602645874,
      "execution_time": 0.08134984970092773,
      "error": "Test execution error: 10\nTest execution error: 10\n",
      "generated_code": "class BinaryIndexedTree:\n    __slots__ = [\"n\", \"c\"]\n\n    def __init__(self, n: int):\n        self.n = n\n        self.c = [0] * (n + 1)\n\n    def update(self, x: int, delta: int):\n        while x <= self.n:\n            self.c[x] += delta\n            x += x & -x\n\n    def query(self, x: int) -> int:\n        s = 0\n        while x > 0:\n            s += self.c[x]\n            x -= x & -x\n        return s\n\n\nclass Solution:\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\n        pos = {v: i for i, v in enumerate(nums2)}\n        tree = BinaryIndexedTree(len(nums1))\n        ans = 0\n        for x, v in enumerate(nums1):\n            y = pos[v] + 1\n            left = tree.query(y - 1)\n            right = len(nums1) - x - (tree.query(len(nums1)) - tree.query(y))\n            ans += left * right\n            tree.update(y, 1)\n        return ans"
    },
    {
      "problem_id": "k-divisible-elements-subarrays",
      "problem_title": "K Divisible Elements Subarrays",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": true,
      "total_tests": 135,
      "passed_tests": 135,
      "api_time": 15.474390029907227,
      "execution_time": 0.06764078140258789,
      "error": null,
      "generated_code": "class Solution:\n    def countDistinct(self, nums: List[int], k: int, p: int) -> int:\n        s = set()\n        n = len(nums)\n        for i in range(n):\n            t = 0\n            for j in range(i, n):\n                t += nums[j] % p == 0\n                if t > k:\n                    break\n                s.add(tuple(nums[i : j + 1]))\n        return len(s)"
    },
    {
      "problem_id": "count-nodes-equal-to-average-of-subtree",
      "problem_title": "Count Nodes Equal To Average Of Subtree",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 76,
      "passed_tests": 0,
      "api_time": 22.279183864593506,
      "execution_time": 0.06417202949523926,
      "error": "Test execution error: 'list' object has no attribute 'left'\nTest execution error: 'str' object has no attribute 'left'\nTest execution error: 'list' object has no attribute 'left'\nTest execution error: 'str' object has no attribute 'left'\nTest execution error: 'list' object has no attribute 'left'\nTest execution error: 'str' object has no attribute 'left'\nTest execution error: 'str' object has no attribute 'left'\nTest execution error: 'str' object has no attribute 'left'\nTest execution error: 'li",
      "generated_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def averageOfSubtree(self, root: TreeNode) -> int:\n        def dfs(root):\n            if root is None:\n                return 0, 0\n            ls, ln = dfs(root.left)\n            rs, rn = dfs(root.right)\n            s, n = ls + rs + root.val, ln + rn + 1\n            nonlocal ans\n            if s // n == root.val:\n                ans += 1\n            return s, n\n\n        ans = 0\n        dfs(root)\n        return ans"
    },
    {
      "problem_id": "count-asterisks",
      "problem_title": "Count Asterisks",
      "difficulty": "Easy",
      "model": "deepseek-leetcode-p3",
      "passed": true,
      "total_tests": 106,
      "passed_tests": 106,
      "api_time": 8.3666250705719,
      "execution_time": 0.060005903244018555,
      "error": null,
      "generated_code": "class Solution:\n    def countAsterisks(self, s: str) -> int:\n        return sum(x.count(\"*\") for x in s.split(\"|\")[::2])"
    },
    {
      "problem_id": "minimum-sum-of-squared-difference",
      "problem_title": "Minimum Sum Of Squared Difference",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 116,
      "passed_tests": 87,
      "api_time": 23.407651901245117,
      "execution_time": 0.06406211853027344,
      "error": "Test execution error: division by zero\nTest execution error: division by zero\nTest execution error: division by zero\nTest execution error: division by zero\nTest execution error: division by zero\nTest execution error: division by zero\nTest execution error: division by zero\nTest execution error: division by zero\nTest execution error: division by zero\nTest execution error: division by zero\nTest execution error: division by zero\nTest execution error: division by zero\nTest execution error: division b",
      "generated_code": "class Solution:\n    def minSumSquareDiff(\n        self, nums1: List[int], nums2: List[int], k1: int, k2: int\n    ) -> int:\n        d = [abs(a - b) for a, b in zip(nums1, nums2)]\n        k = k1 + k2\n        if sum(d) <= k:\n            return 0\n        left, right = 0, max(d)\n        while left < right:\n            mid = (left + right) >> 1\n            cnt = sum((x - mid) // abs(x - mid) for x in d) * abs(mid - min(d))\n            if k >= cnt:\n                right = mid\n            else:\n                left = mid + 1\n        return sum((x - left) ** 2 for x in d)"
    },
    {
      "problem_id": "amount-of-time-for-binary-tree-to-be-infected",
      "problem_title": "Amount Of Time For Binary Tree To Be Infected",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 72,
      "passed_tests": 0,
      "api_time": 27.980430126190186,
      "execution_time": 0.06305694580078125,
      "error": "Test execution error: 'str' object has no attribute 'val'\nTest execution error: 'str' object has no attribute 'val'\nTest execution error: 'list' object has no attribute 'val'\nTest execution error: 'list' object has no attribute 'val'\nTest execution error: 'str' object has no attribute 'val'\nTest execution error: 'list' object has no attribute 'val'\nTest execution error: 'list' object has no attribute 'val'\nTest execution error: 'str' object has no attribute 'val'\nTest execution error: 'str' obje",
      "generated_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\n        def dfs1(root, fa):\n            if root is None:\n                return\n            g[root.val].append(fa)\n            g[fa].append(root.val)\n            dfs1(root.left, root.val)\n            dfs1(root.right, root.val)\n\n        def dfs2(i):\n            if i == -1 or vis[i]:\n                return\n            nonlocal ans\n            vis[i] = True\n            for j in g[i]:\n                ans += 1\n                dfs2(j)\n\n        g = defaultdict(list)\n        dfs1(root, -1)\n        vis = [False] * 100010\n        ans = 0\n        dfs2(start)\n        return ans"
    },
    {
      "problem_id": "smallest-even-multiple",
      "problem_title": "Smallest Even Multiple",
      "difficulty": "Easy",
      "model": "deepseek-leetcode-p3",
      "passed": true,
      "total_tests": 91,
      "passed_tests": 91,
      "api_time": 4.92067813873291,
      "execution_time": 0.05872797966003418,
      "error": null,
      "generated_code": "class Solution:\n    def smallestEvenMultiple(self, n: int) -> int:\n        return n if n % 2 == 0 else n * 2"
    },
    {
      "problem_id": "maximum-number-of-non-overlapping-palindrome-substrings",
      "problem_title": "Maximum Number Of Non Overlapping Palindrome Substrings",
      "difficulty": "Hard",
      "model": "deepseek-leetcode-p3",
      "passed": true,
      "total_tests": 109,
      "passed_tests": 109,
      "api_time": 15.368034839630127,
      "execution_time": 0.062126874923706055,
      "error": null,
      "generated_code": "class Solution:\n    def maxPalindromes(self, s: str, k: int) -> int:\n        @cache\n        def dfs(i):\n            if i >= n:\n                return 0\n            ans = dfs(i + 1)\n            for j in range(i + k - 1, n):\n                if s[i : j + 1] == s[i : j + 1][::-1]:\n                    ans = max(ans, 1 + dfs(j + 1))\n            return ans\n\n        n = len(s)\n        return dfs(0)"
    },
    {
      "problem_id": "remove-nodes-from-linked-list",
      "problem_title": "Remove Nodes From Linked List",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 108,
      "passed_tests": 0,
      "api_time": 16.29309391975403,
      "execution_time": 0.059992074966430664,
      "error": "Test execution error: 'list' object has no attribute 'next'\nTest execution error: 'list' object has no attribute 'next'\nTest execution error: 'list' object has no attribute 'next'\nTest execution error: 'list' object has no attribute 'next'\nTest execution error: 'list' object has no attribute 'next'\nTest execution error: 'list' object has no attribute 'next'\nTest execution error: 'list' object has no attribute 'next'\nTest execution error: 'list' object has no attribute 'next'\nTest execution error",
      "generated_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        stk = []\n        while head:\n            while stk and stk[-1].val < head.val:\n                stk.pop()\n            if not stk:\n                stk.append(head)\n            else:\n                stk[-1].next = head\n            head = head.next\n        return stk[0]"
    },
    {
      "problem_id": "cycle-length-queries-in-a-tree",
      "problem_title": "Cycle Length Queries In A Tree",
      "difficulty": "Hard",
      "model": "deepseek-leetcode-p3",
      "passed": true,
      "total_tests": 70,
      "passed_tests": 70,
      "api_time": 15.658249855041504,
      "execution_time": 0.06352901458740234,
      "error": null,
      "generated_code": "class Solution:\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\n        ans = []\n        for a, b in queries:\n            cnt = 0\n            while a != b:\n                if a > b:\n                    a >>= 1\n                else:\n                    b >>= 1\n                cnt += 1\n            ans.append(cnt + 1)\n        return ans"
    },
    {
      "problem_id": "take-k-of-each-character-from-left-and-right",
      "problem_title": "Take K Of Each Character From Left And Right",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 131,
      "passed_tests": 13,
      "api_time": 17.420966863632202,
      "execution_time": 0.06441092491149902,
      "error": null,
      "generated_code": "class Solution:\n    def takeCharacters(self, s: str, k: int) -> int:\n        cnt = Counter(s)\n        if any(v < k for v in cnt.values()):\n            return -1\n        n = len(s)\n        j = l = 0\n        ans = 0\n        for i, c in enumerate(s):\n            while j < n and s[j] != c:\n                j += 1\n            while j < n and s[j] == c:\n                j += 1\n            t = min(i + 1, l) + (n - j)\n            ans = max(ans, t)\n        return n - ans"
    },
    {
      "problem_id": "minimum-common-value",
      "problem_title": "Minimum Common Value",
      "difficulty": "Easy",
      "model": "deepseek-leetcode-p3",
      "passed": true,
      "total_tests": 103,
      "passed_tests": 103,
      "api_time": 13.59423017501831,
      "execution_time": 0.06328916549682617,
      "error": null,
      "generated_code": "class Solution:\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\n        i = j = 0\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] == nums2[j]:\n                return nums1[i]\n            if nums1[i] < nums2[j]:\n                i += 1\n            else:\n                j += 1\n        return -1"
    },
    {
      "problem_id": "maximum-number-of-integers-to-choose-from-a-range-ii",
      "problem_title": "Maximum Number Of Integers To Choose From A Range Ii",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 107,
      "passed_tests": 0,
      "api_time": 9.715954065322876,
      "execution_time": 30.00912594795227,
      "error": "Timeout after 30 seconds",
      "generated_code": "class Solution:\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\n        s = sum(banned)\n        for i in range(1, n + 1):\n            if s + i > maxSum:\n                return i - 1"
    },
    {
      "problem_id": "merge-two-2d-arrays-by-summing-values",
      "problem_title": "Merge Two 2D Arrays By Summing Values",
      "difficulty": "Easy",
      "model": "deepseek-leetcode-p3",
      "passed": true,
      "total_tests": 93,
      "passed_tests": 93,
      "api_time": 13.101471185684204,
      "execution_time": 0.10920596122741699,
      "error": null,
      "generated_code": "class Solution:\n    def mergeArrays(\n        self, nums1: List[List[int]], nums2: List[List[int]]\n    ) -> List[List[int]]:\n        cnt = Counter()\n        for idi, vali in nums1 + nums2:\n            cnt[idi] += vali\n        return sorted(cnt.items())"
    },
    {
      "problem_id": "count-number-of-possible-root-nodes",
      "problem_title": "Count Number Of Possible Root Nodes",
      "difficulty": "Hard",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 70,
      "passed_tests": 36,
      "api_time": 32.944802045822144,
      "execution_time": 0.08585500717163086,
      "error": null,
      "generated_code": "class Solution:\n    def rootCount(\n        self, edges: List[List[int]], guesses: List[List[int]], k: int\n    ) -> int:\n        def dfs1(i: int, fa: int) -> None:\n            nonlocal cnt\n            for j in g[i]:\n                if j != fa:\n                    cnt += (i, j) in s\n                    dfs1(j, i)\n\n        def dfs2(i: int, fa: int, t: int) -> int:\n            nonlocal ans\n            for j in g[i]:\n                if j != fa:\n                    t += (i, j) in s\n                    t -= (j, i) in s\n            ans += t >= k\n            for j in g[i]:\n                if j != fa:\n                    dfs2(j, i, t)\n\n        cnt = ans = 0\n        g = defaultdict(list)\n        s = {tuple(v) for v in guesses}\n        for a, b in edges:\n            g[a].append(b)\n            g[b].append(a)\n        dfs1(0, -1)\n        dfs2(0, -1, cnt)\n        return ans"
    },
    {
      "problem_id": "smallest-missing-non-negative-integer-after-operations",
      "problem_title": "Smallest Missing Non Negative Integer After Operations",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 133,
      "passed_tests": 67,
      "api_time": 10.727716207504272,
      "execution_time": 0.057524919509887695,
      "error": "Test execution error: \nTest execution error: \nTest execution error: not all arguments converted during string formatting\nTest execution error: not all arguments converted during string formatting\nTest execution error: not all arguments converted during string formatting\nTest execution error: \nTest execution error: not all arguments converted during string formatting\nTest execution error: \nTest execution error: not all arguments converted during string formatting\nTest execution error: not all arg",
      "generated_code": "class Solution:\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\n        cnt = Counter((x % value + value) % value for x in nums)\n        return next(i for i in range(len(nums)) if cnt[i] == 0)"
    },
    {
      "problem_id": "beautiful-pairs",
      "problem_title": "Beautiful Pairs",
      "difficulty": "Hard",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 84,
      "passed_tests": 0,
      "api_time": 15.594993829727173,
      "execution_time": 0.060971975326538086,
      "error": null,
      "generated_code": "class Solution:\n    def beautifulPair(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        mi = inf\n        ans = [0, 0]\n        for i, (a, b) in enumerate(zip(nums1, nums2)):\n            d = abs(a - a) + abs(b - b)\n            if d < mi or (d == mi and ans > [i, i]):\n                mi = d\n                ans = [i, i]\n        return ans"
    },
    {
      "problem_id": "calculate-delayed-arrival-time",
      "problem_title": "Calculate Delayed Arrival Time",
      "difficulty": "Easy",
      "model": "deepseek-leetcode-p3",
      "passed": true,
      "total_tests": 31,
      "passed_tests": 31,
      "api_time": 6.766696214675903,
      "execution_time": 0.06004619598388672,
      "error": null,
      "generated_code": "class Solution:\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\n        return (arrivalTime + delayedTime) % 24"
    },
    {
      "problem_id": "minimum-number-of-operations-to-make-all-array-elements-equal-to-1",
      "problem_title": "Minimum Number Of Operations To Make All Array Elements Equal To 1",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 157,
      "passed_tests": 135,
      "api_time": 15.84925889968872,
      "execution_time": 0.06763482093811035,
      "error": null,
      "generated_code": "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        g = nums[0]\n        for x in nums:\n            g = gcd(g, x)\n            if g == 1:\n                return 0\n        s = sum(nums)\n        if s > 1:\n            return -1\n        ans = 0\n        t = 0\n        for x in nums:\n            t += x - 1\n            ans += 1 + t // g\n            t %= g\n        return ans"
    },
    {
      "problem_id": "find-the-losers-of-the-circular-game",
      "problem_title": "Find The Losers Of The Circular Game",
      "difficulty": "Easy",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 73,
      "passed_tests": 0,
      "api_time": 15.656150817871094,
      "execution_time": 0.06377506256103516,
      "error": null,
      "generated_code": "class Solution:\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\n        vis = [False] * (n + 1)\n        i = 0\n        for j in count(k):\n            i = (i + j) % n or n\n            if vis[i]:\n                break\n            vis[i] = True\n        return [x for x, v in enumerate(vis[1:], 1) if not v]"
    },
    {
      "problem_id": "maximum-strictly-increasing-cells-in-a-matrix",
      "problem_title": "Maximum Strictly Increasing Cells In A Matrix",
      "difficulty": "Hard",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 106,
      "passed_tests": 0,
      "api_time": 39.08319067955017,
      "execution_time": 30.00838279724121,
      "error": "Timeout after 30 seconds",
      "generated_code": "class BinaryIndexedTree:\n    __slots__ = [\"n\", \"c\"]\n\n    def __init__(self, n: int):\n        self.n = n\n        self.c = [0] * (n + 1)\n\n    def update(self, x: int, delta: int):\n        while x <= self.n:\n            self.c[x] += delta\n            x += x & -x\n\n    def query(self, x: int) -> int:\n        s = 0\n        while x > 0:\n            s += self.c[x]\n            x -= x & -x\n        return s\n\n\nclass Solution:\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\n        m, n = len(mat), len(mat[0])\n        tree_row = [BinaryIndexedTree(n) for _ in range(m)]\n        tree_col = [BinaryIndexedTree(m) for _ in range(n)]\n        d = defaultdict(list)\n        for i, row in enumerate(mat):\n            for j, x in enumerate(row):\n                d[x].append((i, j))\n        ans = 0\n        for _, v in sorted(d.items()):\n            for i, j in v:\n                a = tree_row[i].query(j) + 1\n                b = tree_col[j].query(i) + 1\n                ans = max(ans, a, b)\n                tree_row[i].update(j, 1)\n                tree_col[j].update(i, 1)\n        return ans"
    },
    {
      "problem_id": "account-balance-after-rounded-purchase",
      "problem_title": "Account Balance After Rounded Purchase",
      "difficulty": "Easy",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 54,
      "passed_tests": 1,
      "api_time": 8.226944923400879,
      "execution_time": 0.05875992774963379,
      "error": null,
      "generated_code": "class Solution:\n    def accountBalanceAfterPurchase(self, purchaseAmount: int) -> int:\n        x = 10 * round(purchaseAmount / 10)\n        return 100 - abs(x - purchaseAmount)"
    },
    {
      "problem_id": "minimum-absolute-difference-between-elements-with-constraint",
      "problem_title": "Minimum Absolute Difference Between Elements With Constraint",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 213,
      "passed_tests": 0,
      "api_time": 16.100409030914307,
      "execution_time": 0.06404805183410645,
      "error": "Test execution error: name 'SortedList' is not defined\nTest execution error: name 'SortedList' is not defined\nTest execution error: name 'SortedList' is not defined\nTest execution error: name 'SortedList' is not defined\nTest execution error: name 'SortedList' is not defined\nTest execution error: name 'SortedList' is not defined\nTest execution error: name 'SortedList' is not defined\nTest execution error: name 'SortedList' is not defined\nTest execution error: name 'SortedList' is not defined\nTest ",
      "generated_code": "class Solution:\n    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n        sl = SortedList()\n        ans = inf\n        for i in range(x, len(nums)):\n            sl.add(nums[i - x])\n            j = bisect_left(sl, nums[i])\n            if j < len(sl):\n                ans = min(ans, sl[j] - nums[i])\n            if j > 0:\n                ans = min(ans, nums[i] - sl[j - 1])\n        return ans"
    },
    {
      "problem_id": "minimum-operations-to-make-a-special-number",
      "problem_title": "Minimum Operations To Make A Special Number",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 188,
      "passed_tests": 18,
      "api_time": 14.79460883140564,
      "execution_time": 0.06644797325134277,
      "error": null,
      "generated_code": "class Solution:\n    def minimumOperations(self, num: str) -> int:\n        n = len(num)\n        f = [0] * (n + 1)\n        for i in range(1, n + 1):\n            x = 25 * (int(num[i - 2]) if i >= 2 else 0) + int(num[i - 1])\n            f[i] = min(f[i - 1], f[max(0, i - 3)] + 1) + (x % 25 != 0)\n        return f[-1]"
    },
    {
      "problem_id": "sum-of-remoteness-of-all-cells",
      "problem_title": "Sum Of Remoteness Of All Cells",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 100,
      "passed_tests": 2,
      "api_time": 32.46577215194702,
      "execution_time": 0.06406688690185547,
      "error": "Test execution error: list index out of range\nTest execution error: list index out of range\nTest execution error: list index out of range\nTest execution error: list index out of range\nTest execution error: list index out of range\nTest execution error: list index out of range\nTest execution error: list index out of range\nTest execution error: list index out of range\nTest execution error: list index out of range\nTest execution error: list index out of range\nTest execution error: list index out of ",
      "generated_code": "class Solution:\n    def sumRemoteness(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        g = [[[] for _ in range(n)] for _ in range(n)]\n        q = deque()\n        vis = set()\n        for i, row in enumerate(grid):\n            for j, x in enumerate(row):\n                if x == -1:\n                    continue\n                vis.add((i, j))\n                for a, b in [[0, 1], [0, -1], [1, 0], [-1, 0]]:\n                    c, d = i + a, j + b\n                    if (c, d) not in vis:\n                        g[i][j].append((c, d))\n                q.append((i, j))\n        ans = 0\n        while q:\n            for _ in range(len(q)):\n                i, j = q.popleft()\n                for c, d in g[i][j]:\n                    if (c, d) not in vis:\n                        vis.add((c, d))\n                        ans += grid[i][j]\n                        q.append((c, d))\n        return ans"
    },
    {
      "problem_id": "longest-unequal-adjacent-groups-subsequence-i",
      "problem_title": "Longest Unequal Adjacent Groups Subsequence I",
      "difficulty": "Easy",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 209,
      "passed_tests": 0,
      "api_time": 29.18892812728882,
      "execution_time": 0.06543517112731934,
      "error": "Test execution error: '<' not supported between instances of 'int' and 'list'\nTest execution error: '<' not supported between instances of 'int' and 'list'\nTest execution error: '<' not supported between instances of 'int' and 'list'\nTest execution error: '<' not supported between instances of 'int' and 'list'\nTest execution error: '<' not supported between instances of 'int' and 'list'\nTest execution error: '<' not supported between instances of 'int' and 'list'\nTest execution error: '<' not su",
      "generated_code": "class Solution:\n    def getLongestSubsequence(self, words: List[str], groups: List[int]) -> List[str]:\n        n = len(words)\n        f = [[0] * 2 for _ in range(n)]\n        g = [[] for _ in range(n)]\n        for i, (w, x) in enumerate(zip(words, groups)):\n            if i == 0 or groups[i - 1] != x:\n                f[i][x] = 1\n                g[i].append(w)\n            else:\n                j = bisect_left(g[i - 1], w)\n                f[i][x] = max(f[i - 1][0], f[i - 1][1]) + (j > 0 and g[i - 1][j - 1] < w)\n                if j == 0:\n                    g[i].append(w)\n                else:\n                    g[i].extend([g[i - 1][j - 1], w])\n        i = bisect_left(f, [n, n], key=lambda x: -x[1])\n        return g[i]"
    },
    {
      "problem_id": "find-indices-with-index-and-value-difference-ii",
      "problem_title": "Find Indices With Index And Value Difference Ii",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 126,
      "passed_tests": 49,
      "api_time": 16.738762140274048,
      "execution_time": 0.06655621528625488,
      "error": null,
      "generated_code": "class Solution:\n    def findIndices(\n        self, nums: List[int], indexDifference: int, valueDifference: int\n    ) -> List[int]:\n        for i in range(len(nums)):\n            j = bisect_left(nums, nums[i] + valueDifference, lo=max(0, i - indexDifference))\n            if 0 <= j < len(nums) and abs(i - j) >= indexDifference:\n                return [i, j]\n        return [-1, -1]"
    },
    {
      "problem_id": "distribute-candies-among-children-i",
      "problem_title": "Distribute Candies Among Children I",
      "difficulty": "Easy",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 71,
      "passed_tests": 7,
      "api_time": 10.788786888122559,
      "execution_time": 0.05732607841491699,
      "error": null,
      "generated_code": "class Solution:\n    def distributeCandies(self, n: int, limit: int) -> int:\n        if n <= limit * 3:\n            return 1\n        ans = (n // 2 + n % 2) // (limit + 1)\n        if n & 1 and limit == 1:\n            ans += 1\n        return ans"
    },
    {
      "problem_id": "find-building-where-alice-and-bob-can-meet",
      "problem_title": "Find Building Where Alice And Bob Can Meet",
      "difficulty": "Hard",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 112,
      "passed_tests": 0,
      "api_time": 39.82464408874512,
      "execution_time": 0.08611679077148438,
      "error": "Test execution error: list index out of range\n",
      "generated_code": "class BinaryIndexedTree:\n    __slots__ = [\"n\", \"c\"]\n\n    def __init__(self, n: int):\n        self.n = n\n        self.c = [inf] * (n + 1)\n\n    @staticmethod\n    def lowbit(x):\n        return x & -x\n\n    def update(self, x: int, v: int):\n        while x <= self.n:\n            self.c[x] = min(self.c[x], v)\n            x += BinaryIndexedTree.lowbit(x)\n\n    def query(self, x: int) -> int:\n        res = inf\n        while x:\n            res = min(res, self.c[x])\n            x ^= BinaryIndexedTree.lowbit(x)\n        return res\n\n\nclass Solution:\n    def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(heights)\n        tree = BinaryIndexedTree(n + 10)\n        ans = []\n        for i in range(len(queries)):\n            a, b = queries[i]\n            if heights[a] < heights[b]:\n                a, b = b, a\n            tree.update(heights[a], a + 1)\n            ans.append(-1 if i == len(queries) - 1 else tree.query(n + 9))\n        return ans"
    },
    {
      "problem_id": "minimum-number-of-coins-to-be-added",
      "problem_title": "Minimum Number Of Coins To Be Added",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 110,
      "passed_tests": 0,
      "api_time": 11.81469178199768,
      "execution_time": 0.057988882064819336,
      "error": null,
      "generated_code": "class Solution:\n    def minimumAddedCoins(self, coins: List[int], target: int) -> int:\n        ans = 0\n        for i in sorted(coins):\n            if (d := max(target + 1 - ans - i, 0)) > 0:\n                ans += d\n        return ans"
    },
    {
      "problem_id": "earliest-second-to-mark-indices-i",
      "problem_title": "Earliest Second To Mark Indices I",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 114,
      "passed_tests": 25,
      "api_time": 20.2117919921875,
      "execution_time": 0.06621694564819336,
      "error": "Test execution error: list index out of range\n",
      "generated_code": "class Solution:\n    def earliestSecondToMarkIndices(self, nums: List[int], changeIndices: List[int]) -> int:\n        n = len(nums)\n        m = len(changeIndices)\n        for i in range(1, m + 1):\n            if nums[changeIndices[i - 1] - 1] == 0:\n                return i\n            for j in range(n):\n                if nums[j]:\n                    nums[j] -= 1\n        return -1"
    },
    {
      "problem_id": "apple-redistribution-into-boxes",
      "problem_title": "Apple Redistribution Into Boxes",
      "difficulty": "Easy",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 115,
      "passed_tests": 0,
      "api_time": 16.257644176483154,
      "execution_time": 0.06514906883239746,
      "error": "Test execution error: list index out of range\n",
      "generated_code": "class Solution:\n    def minimumBoxes(self, apple: List[int], capacity: List[int]) -> int:\n        n = len(apple)\n        s = list(accumulate(apple))\n        f = [0] * (n + 1)\n        for i in range(1, n + 1):\n            j = 1\n            while j < i and capacity[j - 1] < s[i - 1]:\n                j += 1\n            f[i] = max(f[i], f[j - 1] + j)\n        return min(f[i] for i in range(n + 1))"
    },
    {
      "problem_id": "maximum-total-reward-using-operations-i",
      "problem_title": "Maximum Total Reward Using Operations I",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 104,
      "passed_tests": 5,
      "api_time": 12.027981042861938,
      "execution_time": 0.06216597557067871,
      "error": null,
      "generated_code": "class Solution:\n    def maxTotalReward(self, rewardValues: List[int]) -> int:\n        n = len(rewardValues)\n        f = [0] * (n + 1)\n        for i in range(1, n + 1):\n            f[i] = max(f[i - 1], f[i - 2] + rewardValues[i - 1])\n        return f[-1]"
    },
    {
      "problem_id": "minimum-moves-to-get-a-peaceful-board",
      "problem_title": "Minimum Moves To Get A Peaceful Board",
      "difficulty": "Medium",
      "model": "deepseek-leetcode-p3",
      "passed": false,
      "total_tests": 103,
      "passed_tests": 0,
      "api_time": 28.485981225967407,
      "execution_time": 0.07404279708862305,
      "error": null,
      "generated_code": "class Solution:\n    def minMoves(self, rooks: List[List[int]]) -> int:\n        n = len(rooks)\n        g = defaultdict(list)\n        for i in range(n):\n            x1, y1 = rooks[i]\n            for j in range(n):\n                if i != j:\n                    x2, y2 = rooks[j]\n                    dx, dy = abs(x1 - x2), abs(y1 - y2)\n                    g[(i, min(x1, x2))].append((dx + dy, max(x1, x2)))\n                    g[(min(y1, y2), i)].append((dx + dy, max(y1, y2)))\n        dist = [inf] * n\n        dist[0] = 0\n        q = [(0, 0)]\n        while q:\n            d, i = heappop(q)\n            if dist[i] < d:\n                continue\n            for t, j in g[(i // n, i % n)]:\n                if dist[j] > d + t:\n                    dist[j] = d + t\n                    heappush(q, (dist[j], j))\n        return max(dist[:-1])"
    }
  ]
}